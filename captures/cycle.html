<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>the thing is not the thing</title>
<meta name="description" content="Macro text composed of contradicting micro-ink. Words that form a word that negates them. An animated cycle of emergence, presence, and dissolution.">

<!-- OpenGraph -->
<meta property="og:title" content="the thing is not the thing">
<meta property="og:description" content="Words that form a word that negates them.">
<meta property="og:image" content="https://gserafini.github.io/claude-creative/captures/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:type" content="website">
<meta property="og:url" content="https://gserafini.github.io/claude-creative/captures/cycle.html">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="the thing is not the thing">
<meta name="twitter:description" content="Words that form a word that negates them.">
<meta name="twitter:image" content="https://gserafini.github.io/claude-creative/captures/og-image.png">

<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0d1117;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    overflow: hidden;
  }
  #stage {
    font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
    font-size: 15px;
    line-height: 1.55;
    color: #c9d1d9;
    letter-spacing: 1px;
    min-height: 200px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .row {
    white-space: pre;
    height: 1.55em;
  }
  .px {
    display: inline;
    transition: none;
  }
  #caption {
    font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
    font-size: 13px;
    color: #484f58;
    margin-top: 28px;
    height: 20px;
  }
  #epilogue {
    font-family: 'SF Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
    font-size: 13px;
    color: #484f58;
    position: absolute;
    opacity: 0;
  }
</style>
</head>
<body>
<div id="stage"></div>
<div id="caption"></div>
<div id="epilogue"></div>
<script>
// ── Bitmap font: 5 wide x 7 tall ──
const GLYPHS = {
  A:[14,17,17,31,17,17,17], B:[30,17,17,30,17,17,30],
  C:[14,17,16,16,16,17,14], D:[28,18,17,17,17,18,28],
  E:[31,16,16,30,16,16,31], F:[31,16,16,30,16,16,16],
  G:[14,17,16,23,17,17,14], H:[17,17,17,31,17,17,17],
  I:[14,4,4,4,4,4,14],      K:[17,18,20,24,20,18,17],
  L:[16,16,16,16,16,16,31], M:[17,27,21,21,17,17,17],
  N:[17,25,21,19,17,17,17], O:[14,17,17,17,17,17,14],
  P:[30,17,17,30,16,16,16], R:[30,17,17,30,20,18,17],
  S:[14,17,16,14,1,17,14],  T:[31,4,4,4,4,4,4],
  U:[17,17,17,17,17,17,14], V:[17,17,17,17,10,10,4],
  W:[17,17,17,21,21,27,17], X:[17,10,4,4,4,10,17],
  Y:[17,10,4,4,4,4,4],      Z:[31,1,2,4,8,16,31],
  ' ':[0,0,0,0,0,0,0],
};
const FONT = {};
for (const [c, rows] of Object.entries(GLYPHS)) {
  FONT[c] = rows.map(n => {
    const b = [];
    for (let i = 4; i >= 0; i--) b.push((n >> i) & 1);
    return b;
  });
}

// ── Seeded PRNG ──
function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ── Spatial noise ──
// Each pixel gets a deterministic value 0..1. Used for both
// crystallization order (low values appear first) and
// dissolution order (low values disappear LAST — they formed first, they leave last)
function revealTime(ci, x, y) {
  const n = Math.sin((ci * 5 + x) * 12.9898 + y * 78.233) * 43758.5453;
  return n - Math.floor(n);
}

// ── Configuration ──
const PW = 5; // pixel width in characters
const COMP = { word: 'THING', ink: ['sign','name','word','mark'], sub: 'the thing is not the thing' };
const WORD = COMP.word;
const NLETTERS = WORD.length;

// ── Build pixel grid ──
// Each pixel knows: is it a "glyph pixel" (part of a letter) or a gap?
// Glyph pixels have (ci, x, y) coordinates and a revealTime value.
const stage = document.getElementById('stage');
const captionEl = document.getElementById('caption');
const epilogueEl = document.getElementById('epilogue');

const grid = []; // grid[y][pixelIndex] = { el, ci, x, y, rt, isOn }

for (let y = 0; y < 7; y++) {
  const row = document.createElement('div');
  row.className = 'row';
  const pixels = [];

  for (let ci = 0; ci < NLETTERS; ci++) {
    // Gap before letter (except first)
    if (ci > 0) {
      const gap = document.createElement('span');
      gap.className = 'px';
      gap.textContent = ' '.repeat(PW);
      row.appendChild(gap);
      pixels.push({ el: gap, isGap: true });
    }

    const g = FONT[WORD[ci]] || FONT[' '];
    for (let x = 0; x < 5; x++) {
      const span = document.createElement('span');
      span.className = 'px';
      span.textContent = ' '.repeat(PW);
      row.appendChild(span);

      pixels.push({
        el: span,
        ci, x, y,
        isOn: g[y][x] === 1,
        rt: revealTime(ci, x, y),
        isGap: false,
      });
    }
  }

  stage.appendChild(row);
  grid.push(pixels);
}

// ── Shimmer: determine which ink word a pixel shows at a given frame ──
function inkWord(ci, x, y, frame, shimmer) {
  if (shimmer) {
    const seed = y * 97 + x * 13 + ci * 41;
    const rate = 1 + (seed % 3);
    return COMP.ink[Math.floor(frame / rate + seed) % COMP.ink.length];
  }
  return COMP.ink[(frame + y * 3 + x * 7 + ci * 11) % COMP.ink.length];
}

// ── Timeline ──
const PHASES = [
  { name: 'empty',        start: 0,    end: 1.2 },
  { name: 'crystallize',  start: 1.2,  end: 8.2 },    // 7s sigmoid reveal
  { name: 'arrive',       start: 8.2,  end: 13.2 },    // 5s hold, caption at 2s
  { name: 'ghost',        start: 13.2, end: 20.2 },    // 7s opacity dissolution (web-specific)
  { name: 'silence',      start: 20.2, end: 21.7 },    // 1.5s blank
  { name: 'epilogue',     start: 21.7, end: 24.2 },    // 2.5s "neither is this"
  { name: 'epiloguefade', start: 24.2, end: 26.0 },    // 1.8s fade
  { name: 'finalsilence', start: 26.0, end: 27.0 },    // 1s blank then loop
];
const TOTAL = 27.0;

let startTime = null;
// Debug: ?t=5.0 freezes at 5 seconds
const freezeAt = parseFloat(new URLSearchParams(location.search).get('t'));

function tick(now) {
  if (!startTime) startTime = now;
  const elapsed = isNaN(freezeAt) ? ((now - startTime) / 1000) % TOTAL : freezeAt;
  const frame = Math.floor(elapsed * 6);

  // Determine phase
  let phase = 'finalsilence';
  let t = 0;
  for (const p of PHASES) {
    if (elapsed >= p.start && elapsed < p.end) {
      phase = p.name;
      t = (elapsed - p.start) / (p.end - p.start);
      break;
    }
  }

  // ── Update each pixel ──
  for (let y = 0; y < 7; y++) {
    for (const px of grid[y]) {
      if (px.isGap) continue;

      if (!px.isOn) {
        // Off-pixel: always invisible (unless flicker, handled below)
        px.el.textContent = ' '.repeat(PW);
        px.el.style.opacity = 1;
        continue;
      }

      const word = inkWord(px.ci, px.x, px.y, frame, true);

      switch (phase) {
        case 'empty':
        case 'silence':
        case 'finalsilence':
          px.el.textContent = ' '.repeat(PW);
          px.el.style.opacity = 1;
          break;

        case 'crystallize': {
          // Sigmoid reveal — sharp binary appearance
          const reveal = 1 / (1 + Math.exp(-12 * (t - 0.55)));
          if (reveal > px.rt) {
            px.el.textContent = word.padEnd(PW);
            px.el.style.opacity = 1;
          } else {
            px.el.textContent = ' '.repeat(PW);
            px.el.style.opacity = 1;
          }
          break;
        }

        case 'arrive':
          px.el.textContent = word.padEnd(PW);
          px.el.style.opacity = 1;
          break;

        case 'ghost': {
          // Ghosting dissolution — the heart of the web version
          // Pixels with HIGH revealTime dissolve first (they formed last)
          // Pixels with LOW revealTime dissolve last (they formed first)
          //
          // dissolveThreshold: when this pixel starts fading
          // Pixels that appeared last (rt near 1) start dissolving early (threshold near 0)
          // Pixels that appeared first (rt near 0) start dissolving late (threshold near 1)
          const dissolveThreshold = 1 - px.rt;

          // Apply sigmoid to dissolution progress too — slow start, then cascade
          const dissolveSigmoid = 1 / (1 + Math.exp(-10 * (t - 0.45)));

          // How far past this pixel's threshold are we?
          const fadeWidth = 0.2;
          const pastThreshold = dissolveSigmoid - dissolveThreshold * 0.85;
          const opacity = Math.max(0, Math.min(1, 1 - pastThreshold / fadeWidth));

          px.el.textContent = word.padEnd(PW);
          px.el.style.opacity = opacity;
          break;
        }

        default:
          px.el.textContent = ' '.repeat(PW);
          px.el.style.opacity = 1;
      }
    }
  }

  // ── Caption ──
  switch (phase) {
    case 'arrive':
      captionEl.textContent = t >= 0.4 ? '\u2014 ' + COMP.sub : '';
      break;
    case 'ghost': {
      if (t < 0.5) {
        captionEl.textContent = '\u2014 ' + COMP.sub;
        captionEl.style.opacity = 1;
      } else {
        // Caption fades in second half of ghost phase
        const captionFade = (t - 0.5) / 0.5;
        captionEl.style.opacity = Math.max(0, 1 - captionFade * 1.5);
        // Also dissolve caption text
        const rng = mulberry32(frame * 31);
        captionEl.textContent = '\u2014 ' + COMP.sub.split('').map(ch =>
          rng() < captionFade ? '\u00A0' : ch
        ).join('');
      }
      break;
    }
    default:
      captionEl.textContent = '';
      captionEl.style.opacity = 1;
  }

  // ── Epilogue ──
  if (phase === 'epilogue') {
    epilogueEl.textContent = 'neither is this';
    epilogueEl.style.opacity = 1;
  } else if (phase === 'epiloguefade') {
    const rng = mulberry32(frame * 71);
    epilogueEl.textContent = 'neither is this'.split('').map(ch =>
      rng() < t ? '\u00A0' : ch
    ).join('');
    epilogueEl.style.opacity = Math.max(0, 1 - t);
  } else {
    epilogueEl.style.opacity = 0;
  }

  requestAnimationFrame(tick);
}

requestAnimationFrame(tick);
</script>
</body>
</html>
