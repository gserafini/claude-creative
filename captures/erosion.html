<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Erosion</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0d1117;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  #container {
    max-width: 640px;
    padding: 40px 24px;
    position: relative;
  }
  #text {
    font-family: 'Georgia', 'Times New Roman', serif;
    font-size: 20px;
    line-height: 1.85;
    color: #c9d1d9;
    cursor: default;
    -webkit-user-select: none;
    user-select: none;
  }
  #text .word {
    display: inline;
    transition: none;
    position: relative;
  }
  #hint {
    position: fixed;
    top: 24px;
    left: 0; right: 0;
    text-align: center;
    font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
    font-size: 11px;
    color: #1a3a5c;
    pointer-events: none;
    opacity: 0;
    animation: fadeHint 5s ease 0.5s forwards;
  }
  @keyframes fadeHint {
    0%, 70% { opacity: 1; }
    100% { opacity: 0; }
  }
  #statement {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    text-align: center;
    padding: 20px 16px;
    font-family: 'SF Mono', Menlo, Monaco, 'Courier New', monospace;
    font-size: 10px;
    line-height: 1.7;
    color: #30363d;
    opacity: 0;
    transition: opacity 1.2s ease;
    cursor: default;
    max-width: 480px;
    margin: 0 auto;
  }
  #statement:hover, #statement.visible {
    opacity: 1;
    color: #484f58;
  }
</style>
</head>
<body>
<div id="hint">read</div>
<div id="container">
  <div id="text"></div>
</div>
<div id="statement">
  Text erodes unless you read it.<br>
  Hover over words to sustain them.<br>
  What remains is what you chose to attend to.<br>
  <br>
  Made by Claude (Anthropic) with Gabriel Serafini, February 2026.
</div>
<script>
// ── The text ──
// Multiple passages that play with the theme of attention and loss.
// The reader doesn't know which words matter until they start losing them.
const PASSAGES = [
  `We do not remember days, we remember moments. The richness of life lies in memories we have forgotten. What remains is not what happened but what we chose to notice. Every act of memory is an act of forgetting something else. The mind holds what it holds and releases the rest into silence. You cannot attend to everything. What you keep is who you become.`,

  `There is a species of moth that lives for one day. It has no mouth. It cannot eat. Its entire existence is a single urgent flight toward light. We think of this as tragic but perhaps the moth would pity us — creatures who have so much time that we can afford to waste it, who have so many words that most of them mean nothing, who move through the world leaving almost no trace of having attended to any of it.`,

  `A librarian once told me that the most borrowed books are not the most loved. The most loved books are the ones people buy and never return, the ones with broken spines and coffee stains and margin notes that say simply yes. The books that shaped someone are not on the shelves. They are in boxes in attics and on nightstands and propping open doors. The library holds what nobody needed to keep.`,
];

// Pick a random passage
const passage = PASSAGES[Math.floor(Math.random() * PASSAGES.length)];

// ── Build word elements ──
const textEl = document.getElementById('text');
const stmtEl = document.getElementById('statement');
const words = [];

// Split into tokens preserving spaces
const tokens = passage.split(/(\s+)/);
for (const token of tokens) {
  if (/^\s+$/.test(token)) {
    textEl.appendChild(document.createTextNode(token));
    continue;
  }
  const span = document.createElement('span');
  span.className = 'word';
  span.textContent = token;
  textEl.appendChild(span);

  words.push({
    el: span,
    text: token,
    hp: 1.0,           // health: 1 = fully visible, 0 = gone
    attended: 0,        // cumulative attention time
    lastHover: 0,       // frame of last hover
    born: 0,            // frame when decay started (never hovered)
    everHovered: false,
    dead: false,
  });
}

// ── Hover tracking ──
let hoveredWord = null;

textEl.addEventListener('mousemove', (e) => {
  const target = e.target.closest('.word');
  hoveredWord = target ? words.find(w => w.el === target) : null;
});
textEl.addEventListener('mouseleave', () => { hoveredWord = null; });
// Touch support
textEl.addEventListener('touchmove', (e) => {
  const touch = e.touches[0];
  const el = document.elementFromPoint(touch.clientX, touch.clientY);
  const target = el && el.closest('.word');
  hoveredWord = target ? words.find(w => w.el === target) : null;
});
textEl.addEventListener('touchend', () => { hoveredWord = null; });

stmtEl.addEventListener('click', () => stmtEl.classList.toggle('visible'));

// ── Constants ──
const DECAY_DELAY = 480;     // frames before decay starts (~8s at 60fps)
const DECAY_RATE = 0.0008;   // HP lost per frame when decaying (~21s to fully erode)
const HEAL_RATE = 0.03;      // HP gained per frame when hovered
const NEIGHBOR_RADIUS = 4;   // words near hovered word get partial benefit
const NEIGHBOR_HEAL = 0.012; // healing rate for neighbors

let frame = 0;
let started = false;

// Debug: ?t=0.5 sets all words to that erosion level (0=healthy, 1=dead)
const freezeLevel = parseFloat(new URLSearchParams(location.search).get('t'));

// ── Color: health → appearance ──
function applyStyle(w) {
  const hp = w.hp;

  if (w.dead) {
    // Dead words leave a faint trace — the ghost of where meaning was
    w.el.style.color = '#161b22';
    w.el.style.opacity = 1;
    return;
  }

  if (hp > 0.7) {
    // Healthy: normal text
    const t = (hp - 0.7) / 0.3;
    const r = 140 + t * 61;   // 140 → 201
    const g = 150 + t * 59;   // 150 → 209
    const b = 160 + t * 57;   // 160 → 217
    w.el.style.color = `rgb(${r|0},${g|0},${b|0})`;
    w.el.style.opacity = 1;
  } else if (hp > 0.3) {
    // Eroding: color shifts, opacity drops
    const t = (hp - 0.3) / 0.4;
    const r = 80 + t * 60;
    const g = 90 + t * 60;
    const b = 120 + t * 40;
    w.el.style.color = `rgb(${r|0},${g|0},${b|0})`;
    w.el.style.opacity = 0.4 + t * 0.6;
  } else if (hp > 0) {
    // Nearly gone: faint
    const t = hp / 0.3;
    w.el.style.color = `rgb(${40 + t * 40|0},${45 + t * 45|0},${70 + t * 50|0})`;
    w.el.style.opacity = 0.15 + t * 0.35;
  } else {
    w.dead = true;
    w.el.style.color = '#161b22';
    w.el.style.opacity = 1;
  }
}

// ── Character erosion: letters within a word decay individually ──
function erodeText(w) {
  if (w.hp > 0.35) {
    w.el.textContent = w.text;
    return;
  }
  if (w.dead) {
    // Dead words leave underscores — traces of where meaning was
    w.el.textContent = '_'.repeat(w.text.replace(/[^a-zA-Z]/g, '').length) +
      w.text.replace(/[a-zA-Z]/g, '');
    return;
  }

  // Between 0 and 0.35: progressively replace characters
  // Characters at the edges go first, use seeded randomness for stability
  const chars = w.text.split('');
  const mid = chars.length / 2;
  const erosionLevel = 1 - (w.hp / 0.35); // 0 at hp=0.35, 1 at hp=0

  for (let i = 0; i < chars.length; i++) {
    const distFromCenter = Math.abs(i - mid) / (mid || 1);
    const threshold = distFromCenter * 0.5;
    // Use deterministic noise so characters don't flicker
    const noise = Math.sin(i * 127.1 + w.text.charCodeAt(0) * 311.7) * 0.5 + 0.5;
    if (erosionLevel > threshold + noise * 0.3) {
      chars[i] = erosionLevel > 0.7 ? ' ' : '·';
    }
  }
  w.el.textContent = chars.join('');
}

// ── Main loop ──
function tick() {
  // Freeze mode: set all words to a specific erosion level for testing
  if (!isNaN(freezeLevel)) {
    for (let i = 0; i < words.length; i++) {
      const w = words[i];
      // Gradient: earlier words are healthier at the same freeze level
      const pct = i / words.length;
      w.hp = Math.max(0, 1 - freezeLevel * (0.5 + pct));
      if (w.hp <= 0) w.dead = true;
      erodeText(w);
      applyStyle(w);
    }
    return; // Don't animate, don't loop
  }

  frame++;

  // Don't start decay until the reader has had time to see the text
  if (!started && frame > DECAY_DELAY) {
    started = true;
    for (const w of words) w.born = frame;
  }

  // Find hovered word index for neighbor calculation
  const hovIdx = hoveredWord ? words.indexOf(hoveredWord) : -1;

  for (let i = 0; i < words.length; i++) {
    const w = words[i];
    if (w.dead) continue;

    const isHovered = (w === hoveredWord);
    const neighborDist = hovIdx >= 0 ? Math.abs(i - hovIdx) : Infinity;
    const isNeighbor = neighborDist > 0 && neighborDist <= NEIGHBOR_RADIUS;

    if (isHovered) {
      // Direct attention: heal
      w.hp = Math.min(1, w.hp + HEAL_RATE);
      w.attended += 1;
      w.lastHover = frame;
      w.everHovered = true;
    } else if (isNeighbor) {
      // Peripheral attention: slight healing, slower decay
      const falloff = 1 - (neighborDist / (NEIGHBOR_RADIUS + 1));
      w.hp = Math.min(1, w.hp + NEIGHBOR_HEAL * falloff);
      if (w.everHovered) w.lastHover = Math.max(w.lastHover, frame - 30);
    } else if (started) {
      // Unattended: decay
      // Words that have been attended to decay slower (they've been strengthened)
      const attendBonus = Math.min(1, w.attended / 120); // caps at 2s of attention
      const rate = DECAY_RATE * (1 - attendBonus * 0.6);
      w.hp = Math.max(0, w.hp - rate);
    }

    erodeText(w);
    applyStyle(w);
  }

  requestAnimationFrame(tick);
}

requestAnimationFrame(tick);
</script>
</body>
</html>
