<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>breathe</title>
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #080810; }
canvas { display: block; touch-action: none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let W, H, scale;

  // Mouse state — presence, not interaction
  let mx = -9999, my = -9999;
  let mouseMoving = false;
  let mouseTimer = null;
  let mouseFade = 0;

  document.addEventListener('mousemove', e => {
    mx = e.clientX; my = e.clientY;
    mouseMoving = true;
    clearTimeout(mouseTimer);
    mouseTimer = setTimeout(() => { mouseMoving = false; }, 30000);
  });
  document.addEventListener('mouseleave', () => { mouseMoving = false; });
  document.addEventListener('touchmove', e => {
    const t = e.touches[0];
    mx = t.clientX; my = t.clientY;
    mouseMoving = true;
    clearTimeout(mouseTimer);
    mouseTimer = setTimeout(() => { mouseMoving = false; }, 5000);
  }, { passive: true });
  document.addEventListener('touchend', () => { mouseMoving = false; });

  // Lights
  const lights = [];

  function seed() {
    lights.length = 0;

    // Background clouds — large, dim, slow
    for (let i = 0; i < 5; i++) {
      const warm = Math.random() < 0.2;
      lights.push({
        nx: Math.random(), ny: Math.random(), bx: 0, by: 0,
        r: 200 + Math.random() * 300,
        p1: 20000 + Math.random() * 25000,
        p2: 15000 + Math.random() * 18000,
        ph1: Math.random() * Math.PI * 2,
        ph2: Math.random() * Math.PI * 2,
        dpx: 40000 + Math.random() * 30000,
        dpy: 35000 + Math.random() * 30000,
        dphx: Math.random() * Math.PI * 2,
        dphy: Math.random() * Math.PI * 2,
        da: 30 + Math.random() * 50,
        h: warm ? 35 + Math.random() * 15 : 225 + Math.random() * 30,
        s: warm ? 45 + Math.random() * 25 : 20 + Math.random() * 25,
        l: warm ? 50 + Math.random() * 15 : 40 + Math.random() * 15,
        ma: 0.035 + Math.random() * 0.04,
        depth: 0, cloud: true,
      });
    }

    // Points of light
    for (let i = 0; i < 75; i++) {
      const warm = Math.random() < 0.12;
      const depth = warm ? 0.4 + Math.random() * 0.6 : Math.random();
      lights.push({
        nx: Math.random(), ny: Math.random(), bx: 0, by: 0,
        r: 20 + Math.random() * 55,
        p1: 3500 + Math.random() * 9000,
        p2: 2500 + Math.random() * 7000,
        ph1: Math.random() * Math.PI * 2,
        ph2: Math.random() * Math.PI * 2,
        dpx: 12000 + Math.random() * 25000,
        dpy: 12000 + Math.random() * 25000,
        dphx: Math.random() * Math.PI * 2,
        dphy: Math.random() * Math.PI * 2,
        da: 5 + Math.random() * 25,
        h: warm ? 30 + Math.random() * 25 : 218 + Math.random() * 42,
        s: warm ? 60 + Math.random() * 35 : 28 + Math.random() * 35,
        l: warm ? 58 + Math.random() * 25 : 48 + Math.random() * 25,
        ma: 0.08 + depth * 0.22,
        depth: depth, cloud: false,
      });
    }

    lights.sort((a, b) => a.depth - b.depth);
  }

  seed();

  function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    scale = Math.min(W, H) / 900;
    for (const l of lights) {
      l.bx = l.nx * W;
      l.by = l.ny * H;
    }
  }

  window.addEventListener('resize', resize);
  resize();

  function frame(t) {
    ctx.fillStyle = '#080810';
    ctx.fillRect(0, 0, W, H);

    // Slow tide — the whole field breathes
    const tide = 0.85 + 0.15 * Math.sin(t / 45000);

    // Mouse presence fades in and out gently
    if (mouseMoving) mouseFade = Math.min(1, mouseFade + 0.008);
    else mouseFade = Math.max(0, mouseFade - 0.003);

    ctx.globalCompositeOperation = 'lighter';

    for (const l of lights) {
      // Organic breathing — two layered rhythms
      const b1 = Math.sin(t / l.p1 + l.ph1);
      const b2 = Math.sin(t / l.p2 + l.ph2);
      const breathe = b1 * 0.65 + b2 * 0.35;
      let intensity = (0.4 + 0.6 * (breathe * 0.5 + 0.5)) * tide;

      // Gentle drift
      const x = l.bx + Math.sin(t / l.dpx + l.dphx) * l.da * scale;
      const y = l.by + Math.sin(t / l.dpy + l.dphy) * l.da * scale;

      // Nearby lights breathe a little deeper when you're present
      if (mouseFade > 0 && !l.cloud) {
        const dx = x - mx, dy = y - my;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const inf = Math.max(0, 1 - dist / (250 * scale));
        intensity = Math.min(1, intensity + inf * 0.15 * mouseFade);
      }

      const radius = l.r * scale * (l.cloud ? (0.85 + intensity * 0.15) : (0.5 + intensity * 0.5));
      const alpha = l.ma * intensity;

      const g = ctx.createRadialGradient(x, y, 0, x, y, radius);
      g.addColorStop(0, `hsla(${l.h},${l.s}%,${l.l}%,${alpha})`);
      g.addColorStop(0.35, `hsla(${l.h},${l.s}%,${l.l}%,${alpha * 0.45})`);
      g.addColorStop(1, `hsla(${l.h},${l.s}%,${l.l}%,0)`);

      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = g;
      ctx.fill();
    }

    // Vignette — draws the eye inward
    ctx.globalCompositeOperation = 'source-over';
    const diag = Math.sqrt(W * W + H * H) / 2;
    const vig = ctx.createRadialGradient(W / 2, H / 2, diag * 0.35, W / 2, H / 2, diag);
    vig.addColorStop(0, 'rgba(8,8,16,0)');
    vig.addColorStop(1, 'rgba(8,8,16,0.4)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
